# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_tools', [dirname(__file__)])
        except ImportError:
            import _tools
            return _tools
        if fp is not None:
            try:
                _mod = imp.load_module('_tools', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _tools = swig_import_helper()
    del swig_import_helper
else:
    import _tools
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x


import collections
class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tools.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _tools.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _tools.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _tools.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _tools.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _tools.SwigPyIterator_equal(self, x)

    def copy(self):
        return _tools.SwigPyIterator_copy(self)

    def next(self):
        return _tools.SwigPyIterator_next(self)

    def __next__(self):
        return _tools.SwigPyIterator___next__(self)

    def previous(self):
        return _tools.SwigPyIterator_previous(self)

    def advance(self, n):
        return _tools.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _tools.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _tools.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _tools.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _tools.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _tools.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _tools.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _tools.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def new_doublep():
    return _tools.new_doublep()
new_doublep = _tools.new_doublep

def copy_doublep(value):
    return _tools.copy_doublep(value)
copy_doublep = _tools.copy_doublep

def delete_doublep(obj):
    return _tools.delete_doublep(obj)
delete_doublep = _tools.delete_doublep

def doublep_assign(obj, value):
    return _tools.doublep_assign(obj, value)
doublep_assign = _tools.doublep_assign

def doublep_value(obj):
    return _tools.doublep_value(obj)
doublep_value = _tools.doublep_value

def choose(n, k):
    return _tools.choose(n, k)
choose = _tools.choose

def factorial(number):
    return _tools.factorial(number)
factorial = _tools.factorial

def logfactorial(number):
    return _tools.logfactorial(number)
logfactorial = _tools.logfactorial

def chooseComb(n, k, fullInd):
    return _tools.chooseComb(n, k, fullInd)
chooseComb = _tools.chooseComb

def get_perm(*args):
    return _tools.get_perm(*args)
get_perm = _tools.get_perm

def gammai(a, x):
    return _tools.gammai(a, x)
gammai = _tools.gammai

def beta(z, w):
    return _tools.beta(z, w)
beta = _tools.beta

def betai(p, q, x):
    return _tools.betai(p, q, x)
betai = _tools.betai

def digama(x):
    return _tools.digama(x)
digama = _tools.digama

def clust(data_in, w, ncl, numData, pClusterIndex):
    return _tools.clust(data_in, w, ncl, numData, pClusterIndex)
clust = _tools.clust

def clust_best(data_in, w, ncl, bestnumData, bestClusterIndex, ntry):
    return _tools.clust_best(data_in, w, ncl, bestnumData, bestClusterIndex, ntry)
clust_best = _tools.clust_best

def findNumCl(data_in, w, ntry):
    return _tools.findNumCl(data_in, w, ntry)
findNumCl = _tools.findNumCl

def gq(*args):
    return _tools.gq(*args)
gq = _tools.gq

def gq_gen(a, b, amu0, x, w):
    return _tools.gq_gen(a, b, amu0, x, w)
gq_gen = _tools.gq_gen

def vandermonde_gq(x, w, q):
    return _tools.vandermonde_gq(x, w, q)
vandermonde_gq = _tools.vandermonde_gq

def gchb(kind, n, x, w):
    return _tools.gchb(kind, n, x, w)
gchb = _tools.gchb

def getDomain(data_in, a, b):
    return _tools.getDomain(data_in, a, b)
getDomain = _tools.getDomain

def maxVal(*args):
    return _tools.maxVal(*args)
maxVal = _tools.maxVal

def minVal(*args):
    return _tools.minVal(*args)
minVal = _tools.minVal

def maxIndex(*args):
    return _tools.maxIndex(*args)
maxIndex = _tools.maxIndex

def minIndex(*args):
    return _tools.minIndex(*args)
minIndex = _tools.minIndex

def maxIndexC_2D(vector, icol):
    return _tools.maxIndexC_2D(vector, icol)
maxIndexC_2D = _tools.maxIndexC_2D

def minIndexC_2D(vector, icol):
    return _tools.minIndexC_2D(vector, icol)
minIndexC_2D = _tools.minIndexC_2D

def heap_ext_(arg1, arg2, arg3, arg4, arg5):
    return _tools.heap_ext_(arg1, arg2, arg3, arg4, arg5)
heap_ext_ = _tools.heap_ext_

def computeNPCTerms(ndim, norder):
    return _tools.computeNPCTerms(ndim, norder)
computeNPCTerms = _tools.computeNPCTerms

def computeMultiIndexT(ndim, norder, mi):
    return _tools.computeMultiIndexT(ndim, norder, mi)
computeMultiIndexT = _tools.computeMultiIndexT

def computeMultiIndex(*args):
    return _tools.computeMultiIndex(*args)
computeMultiIndex = _tools.computeMultiIndex

def computeMultiIndexTP(maxorders, mindex):
    return _tools.computeMultiIndexTP(maxorders, mindex)
computeMultiIndexTP = _tools.computeMultiIndexTP

def computeNPCTermsHDMR(ndim, maxorders):
    return _tools.computeNPCTermsHDMR(ndim, maxorders)
computeNPCTermsHDMR = _tools.computeNPCTermsHDMR

def computeMultiIndexHDMR(ndim, maxorders, mindex):
    return _tools.computeMultiIndexHDMR(ndim, maxorders, mindex)
computeMultiIndexHDMR = _tools.computeMultiIndexHDMR

def decodeMindex(sp_mindex, ndim, mindex):
    return _tools.decodeMindex(sp_mindex, ndim, mindex)
decodeMindex = _tools.decodeMindex

def upOrder(mindex, new_mindex):
    return _tools.upOrder(mindex, new_mindex)
upOrder = _tools.upOrder

def is_admis(mindex_try, mindex):
    return _tools.is_admis(mindex_try, mindex)
is_admis = _tools.is_admis

def getOrders(mindex, orders):
    return _tools.getOrders(mindex, orders)
getOrders = _tools.getOrders

def get_invmindex(mi):
    return _tools.get_invmindex(mi)
get_invmindex = _tools.get_invmindex

def get_invmindex_ord(mi):
    return _tools.get_invmindex_ord(mi)
get_invmindex_ord = _tools.get_invmindex_ord

def PCtoPC(*args):
    return _tools.PCtoPC(*args)
PCtoPC = _tools.PCtoPC

def rtbis_mod(func, x1, x2, xacc, x, pcIn, in1, in2, pcOut, out1, out2):
    return _tools.rtbis_mod(func, x1, x2, xacc, x, pcIn, in1, in2, pcOut, out1, out2)
rtbis_mod = _tools.rtbis_mod

def linint(*args):
    return _tools.linint(*args)
linint = _tools.linint

def erff(x):
    return _tools.erff(x)
erff = _tools.erff

def inverf(y0):
    return _tools.inverf(y0)
inverf = _tools.inverf

def invnormcdf(y):
    return _tools.invnormcdf(y)
invnormcdf = _tools.invnormcdf

def normcdf(y):
    return _tools.normcdf(y)
normcdf = _tools.normcdf

def normcdfc(y):
    return _tools.normcdfc(y)
normcdfc = _tools.normcdfc

def generate_uniform(*args):
    return _tools.generate_uniform(*args)
generate_uniform = _tools.generate_uniform

def generate_uniform_lhs(*args):
    return _tools.generate_uniform_lhs(*args)
generate_uniform_lhs = _tools.generate_uniform_lhs

def generate_normal(rvar, zSeed):
    return _tools.generate_normal(rvar, zSeed)
generate_normal = _tools.generate_normal

def generate_normal_lhs(rvar, zSeed):
    return _tools.generate_normal_lhs(rvar, zSeed)
generate_normal_lhs = _tools.generate_normal_lhs

def get_median(data):
    return _tools.get_median(data)
get_median = _tools.get_median

def get_mean(*args):
    return _tools.get_mean(*args)
get_mean = _tools.get_mean

def get_std(data):
    return _tools.get_std(data)
get_std = _tools.get_std

def get_var(data):
    return _tools.get_var(data)
get_var = _tools.get_var

def getMean_Variance(data_c, w, mean):
    return _tools.getMean_Variance(data_c, w, mean)
getMean_Variance = _tools.getMean_Variance

def getMean(*args):
    return _tools.getMean(*args)
getMean = _tools.getMean

def rperm(n, a, rnstate):
    return _tools.rperm(n, a, rnstate)
rperm = _tools.rperm

def getPdf_figtree(source, target, sig, density, weight):
    return _tools.getPdf_figtree(source, target, sig, density, weight)
getPdf_figtree = _tools.getPdf_figtree

def getPdf_cl(data, points, dens, ncl, sfac):
    return _tools.getPdf_cl(data, points, dens, ncl, sfac)
getPdf_cl = _tools.getPdf_cl

def ihsU(*args):
    return _tools.ihsU(*args)
ihsU = _tools.ihsU

def ihsP(ns, np, rpos, dfac, rnstate):
    return _tools.ihsP(ns, np, rpos, dfac, rnstate)
ihsP = _tools.ihsP

def distCorr(spl, dCor):
    return _tools.distCorr(spl, dCor)
distCorr = _tools.distCorr

def invRos(*args):
    return _tools.invRos(*args)
invRos = _tools.invRos

def get_opt_KDEbdwth(data, bdwth):
    return _tools.get_opt_KDEbdwth(data, bdwth)
get_opt_KDEbdwth = _tools.get_opt_KDEbdwth

def Rosen(*args):
    return _tools.Rosen(*args)
Rosen = _tools.Rosen
# This file is compatible with both classic and new-style classes.


