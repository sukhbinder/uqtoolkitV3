<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>UQTk: Uncertainty Quantification Toolkit: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">UQTk: Uncertainty Quantification Toolkit
   &#160;<span id="projectnumber">3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000001"></a>Class <a class="el" href="classArray1D.html">Array1D&lt; T &gt;</a>  </dt>
<dd>double check copy constructor  </dd>
<dt><a class="anchor" id="_todo000002"></a>Class <a class="el" href="classArray2D.html">Array2D&lt; T &gt;</a>  </dt>
<dd>Define copy constructor  </dd>
<dt><a class="anchor" id="_todo000003"></a>Class <a class="el" href="classArray3D.html">Array3D&lt; T &gt;</a>  </dt>
<dd><p class="startdd">Define copy constructor </p>
<p class="enddd">Several functions, e.g. insert/erase columns/rows, available in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> and <a class="el" href="classArray2D.html" title="Stores data of any type T in a 2D array. ">Array2D</a>, are missing.  </p>
</dd>
<dt><a class="anchor" id="_todo000004"></a>Member <a class="el" href="classArray3D.html#ac8640825b685d374f1b499c97891ba97">Array3D&lt; T &gt;::Resize</a>  (const size_t &amp;nx, const size_t &amp;ny, const size_t &amp;nz)</dt>
<dd>Write a better implementation that preserves the original data by copying it to a temporary array and putting the elements back where they were before. This would bring this resize() command more closely in line with vector::resize() function in the original vector class.  </dd>
<dt><a class="anchor" id="_todo000005"></a>Member <a class="el" href="classArray3D.html#ac1991b560439af5dabfb093c056cdbf7">Array3D&lt; T &gt;::Resize</a>  (const size_t &amp;nx, const size_t &amp;ny, const size_t &amp;nz, const T &amp;t)</dt>
<dd>Write an implementation that is more closely follows the resize command in the vector class, which keeps the original elements and only initializes the new elements.  </dd>
<dt><a class="anchor" id="_todo000006"></a>File <a class="el" href="arraytools_8h.html">arraytools.h</a>  </dt>
<dd><p class="startdd">Some functions are not optimal in terms of array access. They could be slower than MATLAB counterparts. </p>
<p class="enddd">Some functions should be templated and or moved to array class  </p>
</dd>
<dt><a class="anchor" id="_todo000013"></a>globalScope&gt; Member <a class="el" href="bcs_8h.html#a37e7640e112c05716e1a15d3854a9a35">BCS</a>  (<a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;PHI, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;y, double &amp;sigma2, double eta, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;lambda_init, int adaptive, int optimal, double scale, int verbose, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;weights, <a class="el" href="classArray1D_3_01int_01_4.html">Array1D&lt; int &gt;</a> &amp;used, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;errbars, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;basis, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;alpha, double &amp;lambda)</dt>
<dd>The array manipulations are not optimized - perhaps they need to be reconsidered using, say, fortran matrix-vector manipulation routines  </dd>
<dt><a class="anchor" id="_todo000011"></a>globalScope&gt; Member <a class="el" href="arraytools_8h.html#ab282bf9be9d3f828dab3eea48160f934">delCol</a>  (Array1D&lt; T &gt; &amp;x, int icol)</dt>
<dd>This should move to <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> class  </dd>
<dt><a class="anchor" id="_todo000010"></a>globalScope&gt; Member <a class="el" href="arraytools_8h.html#a5079afb7e1dc27415eb8f983f9051a98">delCol</a>  (Array2D&lt; T &gt; &amp;A, int icol)</dt>
<dd>This should move to <a class="el" href="classArray2D.html" title="Stores data of any type T in a 2D array. ">Array2D</a> class  </dd>
<dt><a class="anchor" id="_todo000009"></a>globalScope&gt; Member <a class="el" href="arraytools_8h.html#a6335893f712bbd849051e4870ae72993">delRow</a>  (Array2D&lt; T &gt; &amp;A, int irow)</dt>
<dd>This should move to <a class="el" href="classArray2D.html" title="Stores data of any type T in a 2D array. ">Array2D</a> class  </dd>
<dt><a class="anchor" id="_todo000007"></a>globalScope&gt; Member <a class="el" href="arraytools_8h.html#afe4c308b7d749b067c6decc2d2ea75dc">generate_multigrid</a>  (Array2D&lt; T &gt; &amp;multigrid, Array2D&lt; T &gt; &amp;grid)</dt>
<dd>Should ideally be written in a recursive manner, similar to <a class="el" href="multiindex_8cpp.html#a279f0042f33de462cd660e27001f9ccc" title="Computes the multiindex set of a PC basis for Tensor-Product truncation with a given maximum order pe...">computeMultiIndexTP()</a> in <a class="el" href="multiindex_8cpp.html" title="Tools that deal with integer multiindices. ">tools/multiindex.cpp</a>  </dd>
<dt><a class="anchor" id="_todo000047"></a>globalScope&gt; Member <a class="el" href="probability_8h.html#a7347fd91b04310145aa6d4e0d93aa92e">generate_normal_lhs</a>  (<a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;rvar, int zSeed)</dt>
<dd>LHS generation is far from optimal, it is quite slow  </dd>
<dt><a class="anchor" id="_todo000012"></a>globalScope&gt; Member <a class="el" href="arraytools_8h.html#a513ef63f2bc77afd31649cafcfbd2498">logdeterm</a>  (<a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;mat)</dt>
<dd>Check and catch the symmetric and positiv-definite conditions.  </dd>
<dt><a class="anchor" id="_todo000043"></a>globalScope&gt; Member <a class="el" href="minmax_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>  </dt>
<dd>See if we could move this to the CMake installation scripts instead  </dd>
<dt><a class="anchor" id="_todo000052"></a>globalScope&gt; Member <a class="el" href="pce__eval_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>  (int argc, char *argv[])</dt>
<dd>Make the input arguments more transparent, i.e. what do they mean in different scenarios?  </dd>
<dt><a class="anchor" id="_todo000044"></a>File <a class="el" href="multiindex_8h.html">multiindex.h</a>  </dt>
<dd>Multiindex could be a separate class and a part of core UQTk.  </dd>
<dt><a class="anchor" id="_todo000017"></a>Member <a class="el" href="classPCBasis.html#a92255e562e1a83b715a52801d6b7fa5f">PCBasis::EvalBasis</a>  (const double &amp;xi, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;basisEvals) const </dt>
<dd>Import the recursion coefficients in a more friendly fashion.  </dd>
<dt><a class="anchor" id="_todo000016"></a>Member <a class="el" href="classPCBasis.html#a7434a70f3b962f0e375a9a5edd9508ec">PCBasis::Init1dQuadPoints</a>  (int qdpts)</dt>
<dd>Come up with a smarter way to pick the number of quadrature points <dl class="section note"><dt>Note</dt><dd>Quadrature points are set according to the basis function type </dd>
<dd>
quadPoints is a 2D array but its second dimension is equal to 1.  </dd></dl>
</dd>
<dt><a class="anchor" id="_todo000015"></a>Member <a class="el" href="classPCBasis.html#a000d56b87ef6a80ee6dcf4c51a49066f">PCBasis::PCBasis</a>  (const string type="LU", const double alpha=0.0, const double betta=1.0, const int maxord=10)</dt>
<dd>At some point, the basis selection should probably be implemented in a more elegant way using base and inherited classes. For the time being, Hermite-Gaussian or Legendre-Uniform will probably be the most commonly used cases. The parameters alpha and betta are relevant only for GLG, SW and JB chaoses <dl class="section note"><dt>Note</dt><dd>Maxord specifies the maximal order up to which the computations are performed  </dd></dl>
</dd>
<dt><a class="anchor" id="_todo000018"></a>Member <a class="el" href="classPCBasis.html#add6375d6c2e66eb0ea4ca938bd2875a6">PCBasis::rnstate_</a>  </dt>
<dd>need more functionalities to get/set this variable from user  </dd>
<dt><a class="anchor" id="_todo000045"></a>File <a class="el" href="pcmaps_8h.html">pcmaps.h</a>  </dt>
<dd><p class="startdd">Perhaps use more robust tools, like dcdflib. </p>
<p class="enddd">Need more testing of these tools.  </p>
</dd>
<dt><a class="anchor" id="_todo000038"></a>Member <a class="el" href="classPCSet.html#a96b16eea0c145deed7a14fa02490883d">PCSet::ComputeJointSens</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;coef, <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;jointsens)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000036"></a>Member <a class="el" href="classPCSet.html#abf1c360cc8e305e50a1d418cc084550b">PCSet::ComputeMainSens</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;coef, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;mainsens)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000034"></a>Member <a class="el" href="classPCSet.html#a99b0d9532eff6f625b5db8583354f9d5">PCSet::ComputeOrders</a>  (<a class="el" href="classArray1D_3_01int_01_4.html">Array1D&lt; int &gt;</a> &amp;orders)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000037"></a>Member <a class="el" href="classPCSet.html#a4dc8071222615802f791f74ddb06f9a7">PCSet::ComputeTotSens</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;coef, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;totsens)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000027"></a>Member <a class="el" href="classPCSet.html#abbee1aa5082a7366fe473036ba83842d">PCSet::Derivative</a>  (const double *p1, double *p2) const </dt>
<dd><p class="startdd">Supports LU and HG bases only </p>
<p class="enddd">Supports only for 1d PCs  </p>
</dd>
<dt><a class="anchor" id="_todo000028"></a>Member <a class="el" href="classPCSet.html#a5115eea512b650b85e6762afe9b9440a">PCSet::Derivative</a>  (const <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;p1, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;p2) const </dt>
<dd><p class="startdd">Supports LU and HG bases only </p>
<p class="enddd">Supports only for 1d PCs  </p>
</dd>
<dt><a class="anchor" id="_todo000024"></a>Member <a class="el" href="classPCSet.html#aa6973a234d43c6216d3598e275d3cf96">PCSet::Div</a>  (const double *p1, const double *p2, double *p3) const </dt>
<dd>Remove duplication of data and parameters that was required for enforcing imposed "const" constraints on some of the arguments and the class data members when they are being passed to fortran.  </dd>
<dt><a class="anchor" id="_todo000029"></a>Member <a class="el" href="classPCSet.html#a65ea0d982e84c54269de467def9ea5ca">PCSet::DrawSampleVar</a>  (<a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;samples) const </dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000035"></a>Member <a class="el" href="classPCSet.html#ad385fc95c37e6b87603e676120d304be">PCSet::EncodeMindex</a>  (<a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a>&lt; <a class="el" href="classArray2D.html">Array2D&lt; int &gt;</a> &gt; &amp;sp_mindex)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000031"></a>Member <a class="el" href="classPCSet.html#a8dc2cf2106a31b170bedd48be02bf179">PCSet::EvalBasisAtCustPts</a>  (const <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;custPoints, <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;psi)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000039"></a>Member <a class="el" href="classPCSet.html#a06722aecd7b0201b4a4e5c743ea4045f">PCSet::EvalNormSq</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;normsq)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000040"></a>Member <a class="el" href="classPCSet.html#a29b42d8259a2f8dd8f2cf47cbcd7aa8e">PCSet::EvalNormSqExact</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;normsq)</dt>
<dd>There is no double* version of this function <dl class="section note"><dt>Note</dt><dd>Custom PCs do not have this capability  </dd></dl>
</dd>
<dt><a class="anchor" id="_todo000030"></a>Member <a class="el" href="classPCSet.html#a1cf513a3e88ed2842fa99a2c510f16a3">PCSet::EvalPCAtCustPoints</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;xch, <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;custPoints, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;p)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000032"></a>Member <a class="el" href="classPCSet.html#a02aada88e0176ac83439a9c0ce587b6b">PCSet::GalerkProjection</a>  (const <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;fcn, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;ck)</dt>
<dd><p class="startdd">Overload this with forward function pointers </p>
<p class="enddd">There is no double* version of this function  </p>
</dd>
<dt><a class="anchor" id="_todo000033"></a>Member <a class="el" href="classPCSet.html#a2269cbf763ed3d5f396dbfc187f6772b">PCSet::GalerkProjectionMC</a>  (const <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;x, const <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;fcn, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;ck)</dt>
<dd><p class="startdd">Overload this with forward function pointers </p>
<p class="enddd">There is no double* version of this function  </p>
</dd>
<dt><a class="anchor" id="_todo000020"></a>Member <a class="el" href="classPCSet.html#aef80e902457132ce7ea94ccc78b64ea4">PCSet::GetNormSq</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;normsq) const </dt>
<dd>this seems like a duplication, see below <a class="el" href="classPCSet.html#a652f515895963a080e436d062c839490" title="Get the basis polynomial norms-squared in an array class object psisq. ">GetPsiSq()</a>  </dd>
<dt><a class="anchor" id="_todo000041"></a>Member <a class="el" href="classPCSet.html#a849c4c41a7be1444c7255375874d7e8e">PCSet::Initialize</a>  (const string ordertype)</dt>
<dd>Test and allow intrusive implementation with customized multiindices  </dd>
<dt><a class="anchor" id="_todo000021"></a>Member <a class="el" href="classPCSet.html#af8f5b2268e4d85e9aa9e139abbbc1192">PCSet::InitMeanStDv</a>  (const double &amp;m, const double &amp;s, double *p) const </dt>
<dd>Make this function work for general multi-indices, and for any number of stochastic dimensions  </dd>
<dt><a class="anchor" id="_todo000022"></a>Member <a class="el" href="classPCSet.html#a0dfc15c02421cffee65a6c491cf15e0a">PCSet::InitMeanStDv</a>  (const double &amp;m, const double &amp;s, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;p) const </dt>
<dd>Make this function work for general multi-indices, and for any number of stochastic dimensions  </dd>
<dt><a class="anchor" id="_todo000042"></a>Member <a class="el" href="classPCSet.html#adf4e158bc9d58d417047a0cf0370a57d">PCSet::LogIntRhsWrapper</a>  (realtype t, N_Vector y, N_Vector ydot, void *f_data)</dt>
<dd>Why is this function a static int instead of static void? Should there be a return statement at the end?  </dd>
<dt><a class="anchor" id="_todo000023"></a>Member <a class="el" href="classPCSet.html#a5128f399c1944f7819556072889713f1">PCSet::PolynMulti</a>  (const <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;polycf, const <a class="el" href="classArray2D.html">Array2D&lt; int &gt;</a> &amp;mindex, const <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;p1, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;p2) const </dt>
<dd>A double* version should be added.  </dd>
<dt><a class="anchor" id="_todo000019"></a>Member <a class="el" href="classPCSet.html#a993d6c600aad5e25e0e0311598cbc047">PCSet::SetQuadRule</a>  (const string grid_type, const string fs_type, int param)</dt>
<dd>Need to improve it  </dd>
<dt><a class="anchor" id="_todo000026"></a>Member <a class="el" href="classPCSet.html#ac1445bd2c8921136fdcddbe3d76610f9">PCSet::StDv</a>  (const <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;p) const </dt>
<dd>Lift the assumption by looking for the constant term in the multiindex <dl class="section note"><dt>Note</dt><dd>For a more general implementation, see <a class="el" href="classPCSet.html#a374e64f6fa4b9262335e87661d935f7e" title="Compute the variance fractions of each basis term given coefficients in double *coef; returns the var...">ComputeVarFrac()</a>  </dd></dl>
</dd>
<dt><a class="anchor" id="_todo000025"></a>Member <a class="el" href="classPCSet.html#ae8247f64545d6977c2b136d064b7d99f">PCSet::StDv</a>  (const double *p) const </dt>
<dd>Lift the assumption by looking for the constant term in the multiindex  </dd>
<dt><a class="anchor" id="_todo000046"></a>File <a class="el" href="probability_8h.html">probability.h</a>  </dt>
<dd>There shuold be a RNG class as a part of core UQTk - most of these functions will fit there.  </dd>
<dt><a class="anchor" id="_todo000049"></a>Member <a class="el" href="classQuad.html#a5df24a12fdbed7e3d4d9d28e0677c923">Quad::create1DRule_pdf</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;qdpts, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;wghts, int ngr, double a, double b)</dt>
<dd>Recursive coefficients are given in a file 'ab.dat'; will need to make this more friendly  </dd>
<dt><a class="anchor" id="_todo000048"></a>Member <a class="el" href="classQuad.html#a1a59877017927a85753957a0d0856365">Quad::nextLevel</a>  ()</dt>
<dd>Comment this better  </dd>
<dt><a class="anchor" id="_todo000008"></a>globalScope&gt; Member <a class="el" href="arraytools_8h.html#a4ad5a87ae0b31ba9e14e84fc0de0199e">setdiff_s</a>  (<a class="el" href="classArray1D_3_01int_01_4.html">Array1D&lt; int &gt;</a> &amp;A, <a class="el" href="classArray1D_3_01int_01_4.html">Array1D&lt; int &gt;</a> &amp;B, <a class="el" href="classArray1D_3_01int_01_4.html">Array1D&lt; int &gt;</a> &amp;C)</dt>
<dd>In future, this should sort A too and replace setdiff <dl class="section note"><dt>Note</dt><dd>B is sorted on output as well  </dd></dl>
</dd>
<dt><a class="anchor" id="_todo000051"></a>globalScope&gt; Member <a class="el" href="pce__rv_8cpp.html#ad876cdd1a72412cf2e0d2fcde266dd9a">usage</a>  ()</dt>
<dd>Add more detailed information on options. E.g. what are the different options for type of random variable? When does the order need to be specified?  </dd>
<dt><a class="anchor" id="_todo000014"></a>globalScope&gt; Member <a class="el" href="bcs_8h.html#adc1df47b49e925aba2a5067732f74188">WBCS</a>  (<a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;PHI, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;y, double &amp;sigma2, double eta, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;lambda_init, int adaptive, int optimal, double scale, int verbose, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;weights, <a class="el" href="classArray1D_3_01int_01_4.html">Array1D&lt; int &gt;</a> &amp;used, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;errbars, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;basis, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;alpha, double &amp;lambda, <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;Sig)</dt>
<dd>The array manipulations are not optimized - perhaps they need to be reconsidered using, say, fortran matrix-vector manipulation routines  </dd>
<dt><a class="anchor" id="_todo000050"></a>Member <a class="el" href="classXMLElement.html#a03ab18d6c6f234b9ec741b8f2d9b629c">XMLElement::get_child</a>  (const std::string &amp;)</dt>
<dd>Make this more elegant with the STL find_if function </dd>
</dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 16 2016 17:02:10 for UQTk: Uncertainty Quantification Toolkit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
